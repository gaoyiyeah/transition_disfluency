第一类:buffer本身
        W1:一元:buffer_0是否与右边窗口内词相同 VS buffer_0与窗口内的词依次是否相同,这个跟原先的特征提取方式一致
        W2:二元:buffer_0_1是否与右边窗口内词组相同 VS buffer_0_1与窗口内的词组依次是否相同,这个跟原先的特征提取方式一致
       # W3:三元:buffer_0_1_2是否与右边窗口内词组相同 VS buffer_0_1_2与窗口内的词组依次是否相同,这个跟原先的特征提取方式一致
        P1:一元:buffer_0是否与右边窗口内词性相同 VS buffer_0与窗口内的词性依次是否相同,这个跟原先的特征提取方式一致
        P2:二元:buffer_0_1是否与右边窗口内词性组相同 VS buffer_0_1与窗口内的词性组依次是否相同,这个跟原先的特征提取方式一致
       # P3:三元:buffer_0_1_2是否与右边窗口内词性组相同 VS buffer_0_1_2与窗口内的词性组依次是否相同,这个跟原先的特征提取方式一致
第二类:
     stack与buffer的交互特征:
        W1_1:一元:stack_0是否与后面的相等 | 需要每个位置一个vector吗?
        W2:二元:stack_0_1是否与后面的相等 | 需要每个位置一个vector吗?
        #W3:多元:stack块是否与后面的相等 | 需要每个位置一个vector吗?
        P1_1:一元:stack_0是否与后面的相等 | 需要每个位置一个vector吗?
        P2:二元:stack_0_1是否与后面的相等 | 需要每个位置一个vector吗?
       # P3:多元:stack块是否与后面的相等 | 需要每个位置一个vector吗?
第三类:fuzzy——match,两个改进,扩大窗口,复数简单匹配
提取方法:
 vector<float> features(stack, buffer){

 }


注意事项:到底是只判断后面有没有重复的,还是跟之前的一样,根据位置来判断,这块需要仔细斟酌一下啊






